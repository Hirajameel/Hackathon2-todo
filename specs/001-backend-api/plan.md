# Implementation Plan: Secure Multi-User Todo Backend API

**Branch**: `001-backend-api` | **Date**: 2026-02-08 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-backend-api/spec.md`

## Summary

Build a production-ready FastAPI backend service that provides secure, stateless REST API endpoints for the Todo application. The backend verifies JWT tokens issued by Better Auth (frontend), enforces user isolation, manages task CRUD operations, and persists data to Neon PostgreSQL using SQLModel ORM.

## Technical Context

**Language/Version**: Python 3.11+
**Primary Dependencies**: FastAPI 0.109+, SQLModel 0.0.14+, python-jose[cryptography], psycopg2-binary, pydantic-settings
**Storage**: Neon PostgreSQL (serverless)
**Testing**: pytest with FastAPI TestClient
**Target Platform**: Linux server (containerized deployment)
**Project Type**: Web (backend API only)
**Performance Goals**: <200ms p95 latency for API responses under normal load
**Constraints**: Stateless design (no sessions), JWT-only authentication, strict user isolation, CORS-enabled for frontend
**Scale/Scope**: Multi-user todo application, ~100 concurrent users expected, horizontal scaling support required

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### ✅ Spec-Driven Development Only
- Feature has approved specification at `specs/001-backend-api/spec.md`
- All requirements clearly documented with acceptance criteria
- No implementation will proceed without this plan approval

### ✅ No Manual Coding
- All code will be generated by Claude Code via specifications
- Human role limited to Product Architect and Specification Reviewer

### ✅ Separation of Concerns
- Backend is completely separate from frontend (different directory, different runtime)
- Backend never directly accesses frontend code or state
- Clear API contract boundary between layers

### ✅ Authentication & Security
- All API endpoints require valid JWT token (FR-001 to FR-006)
- JWT verification using BETTER_AUTH_SECRET environment variable
- User identity extracted from JWT claims only, never from request body

### ✅ User Isolation
- All database queries filter by authenticated user_id (FR-021)
- Path parameter user_id validated against JWT user_id (FR-005)
- 403 Forbidden returned for any user_id mismatch

### ✅ API Consistency
- All endpoints follow RESTful conventions
- All endpoints under /api/ path
- JSON responses with proper HTTP status codes (FR-025)

### ✅ Database Integrity
- All tasks associated with user_id (FR-020)
- SQLModel ORM used for all database access (FR-019)
- No raw SQL queries

### ✅ Monorepo Discipline
- Specifications stored in /specs/001-backend-api/
- Backend code will be in /backend/ directory
- CLAUDE.md rules respected

### ✅ Evaluation Readiness
- End-to-end authentication flow demonstrable
- User isolation provable through testing
- All acceptance scenarios testable

**GATE STATUS**: ✅ PASSED - All constitutional requirements satisfied

## Project Structure

### Documentation (this feature)

```text
specs/001-backend-api/
├── spec.md              # Feature specification (complete)
├── plan.md              # This file (in progress)
├── research.md          # Phase 0 output (to be created)
├── data-model.md        # Phase 1 output (to be created)
├── quickstart.md        # Phase 1 output (to be created)
├── contracts/           # Phase 1 output (to be created)
│   ├── openapi.yaml     # OpenAPI 3.0 specification
│   └── task-schema.json # Task entity JSON schema
└── tasks.md             # Phase 2 output (/sp.tasks command)
```

### Source Code (repository root)

```text
backend/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI application entry point
│   ├── config.py               # Environment variable configuration
│   ├── database.py             # Database engine and session management
│   ├── models.py               # SQLModel database models (Task)
│   ├── schemas.py              # Pydantic request/response schemas
│   ├── dependencies.py         # Dependency injection (get_db, get_current_user)
│   ├── middleware/
│   │   ├── __init__.py
│   │   └── auth.py             # JWT verification middleware
│   └── routers/
│       ├── __init__.py
│       └── tasks.py            # Task-related API routes
├── tests/
│   ├── __init__.py
│   ├── conftest.py             # Pytest fixtures (test client, test DB)
│   ├── test_auth.py            # Authentication/authorization tests
│   ├── test_tasks.py           # Task CRUD endpoint tests
│   └── test_models.py          # Database model tests
├── .env.example                # Example environment variables
├── .gitignore                  # Git ignore file
├── requirements.txt            # Python dependencies
├── README.md                   # Setup and usage instructions
└── alembic/                    # Database migrations (optional for MVP)
    ├── versions/
    ├── env.py
    └── alembic.ini
```

**Structure Decision**: Web application structure (Option 2) selected. Backend is isolated in `/backend/` directory with clear separation from frontend. This aligns with the monorepo structure and constitutional requirement for separation of concerns.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No violations detected. All constitutional requirements are satisfied by the current design.

---

## Phase 0: Research & Technology Validation

### Research Questions

Based on the Technical Context, the following areas require research and validation:

1. **JWT Verification with Better Auth**
   - How to verify JWT tokens issued by Better Auth in FastAPI?
   - What claims does Better Auth include in JWT tokens?
   - How to extract user_id from Better Auth JWT payload?

2. **SQLModel with Neon PostgreSQL**
   - Best practices for SQLModel engine configuration with Neon?
   - Connection pooling recommendations for serverless PostgreSQL?
   - How to handle SSL requirements for Neon connections?

3. **FastAPI Authentication Patterns**
   - Best approach for JWT dependency injection in FastAPI?
   - How to implement user_id validation in route dependencies?
   - Error handling patterns for authentication failures?

4. **CORS Configuration**
   - Proper CORS setup for FastAPI with Next.js frontend?
   - Handling preflight OPTIONS requests?
   - Security considerations for CORS origins?

5. **Testing Strategy**
   - How to mock JWT tokens in pytest for FastAPI?
   - Best practices for testing database operations with SQLModel?
   - Integration testing approach for authenticated endpoints?

### Research Output

Research findings will be documented in `research.md` with the following structure:
- Decision: What was chosen
- Rationale: Why it was chosen
- Alternatives considered: What else was evaluated
- Implementation guidance: Key code patterns and configurations

---

## Phase 1: Design Artifacts

### Data Model (data-model.md)

Will document:
- Task entity with all fields and constraints
- Database indexes for performance
- Relationships and foreign keys (if any)
- Validation rules at database level

### API Contracts (contracts/)

Will generate:
- **openapi.yaml**: Complete OpenAPI 3.0 specification with all endpoints
- **task-schema.json**: JSON Schema for Task entity
- Request/response examples for all endpoints
- Error response schemas

### Quickstart Guide (quickstart.md)

Will provide:
- Environment setup instructions
- Database initialization steps
- Running the development server
- Testing the API with curl/httpie examples
- Common troubleshooting scenarios

---

## Next Steps

1. ✅ Complete plan.md (this file)
2. ✅ Generate research.md (Phase 0)
3. ✅ Generate data-model.md (Phase 1)
4. ✅ Generate contracts/ (Phase 1)
5. ✅ Generate quickstart.md (Phase 1)
6. ⏳ Update agent context (manual step - add FastAPI, SQLModel, python-jose to CLAUDE.md if needed)
7. ⏳ Run /sp.tasks to generate tasks.md (Phase 2)

**Current Status**: Planning complete - all design artifacts generated. Ready for /sp.tasks command.
