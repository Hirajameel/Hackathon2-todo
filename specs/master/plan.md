# Phase II – Frontend Implementation Plan (sp.plan)

**Branch**: `master` | **Date**: 2026-02-07 | **Spec**: [specs/frontend-ui/spec.md](../frontend-ui/spec.md)
**Input**: Feature specification from `/specs/frontend-ui/spec.md`

## Summary

Build a professional Next.js 16+ frontend for a multi-user todo application with JWT-based authentication, task management capabilities, and responsive design. The frontend will communicate securely with a FastAPI backend, implement Better Auth for authentication flows, and provide a clean, minimal UI following modern web application patterns.

## Technical Context

**Language/Version**: TypeScript 5.x with Next.js 16+ (App Router)
**Primary Dependencies**: Next.js 16+, Better Auth, Tailwind CSS, React 19+
**Storage**: JWT tokens in httpOnly cookies (managed by Better Auth)
**Testing**: Jest with React Testing Library
**Target Platform**: Modern web browsers (Chrome, Firefox, Safari, Edge - latest 2 versions)
**Project Type**: Web application (frontend only)
**Performance Goals**:
- Dashboard load within 3 seconds
- Task operations visual feedback within 0.5 seconds
- Core Web Vitals: LCP < 2.5s, FID < 100ms, CLS < 0.1
**Constraints**:
- No direct database access from frontend
- All API calls must include JWT authentication
- Mobile responsive down to 320px width
- Accessibility score 95%+
**Scale/Scope**:
- 5 main pages (login, signup, dashboard, task create/edit)
- 10-15 reusable components
- Single-user session management
- Support for hundreds of tasks per user

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### ✅ Spec-Driven Development Only
- **Status**: PASS
- **Evidence**: This plan is derived from approved frontend-ui/spec.md specification

### ✅ No Manual Coding
- **Status**: PASS
- **Evidence**: All implementation will be generated by Claude Code following this plan

### ✅ Separation of Concerns
- **Status**: PASS
- **Evidence**: Frontend will never directly access database; all data operations through backend API

### ✅ Authentication & Security
- **Status**: PASS
- **Evidence**: JWT tokens automatically attached to all API requests via centralized client; no manual token handling in components

### ✅ Frontend Discipline
- **Status**: PASS
- **Evidence**: Centralized API client (REQ-API-001) ensures consistent authentication; no direct fetch calls in UI components

### ✅ Monorepo Discipline
- **Status**: PASS
- **Evidence**: Frontend code will reside in /frontend directory; specs in /specs/frontend-ui; follows Spec-Kit conventions

### ✅ API Consistency
- **Status**: PASS
- **Evidence**: All API endpoints accessed under /api/ path; JSON responses expected; proper HTTP status code handling

### ✅ User Isolation
- **Status**: PASS (Backend Responsibility)
- **Evidence**: Frontend will send JWT with every request; backend enforces user isolation

## Project Structure

### Documentation (this feature)

```text
specs/master/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (/sp.plan command)
├── data-model.md        # Phase 1 output (/sp.plan command)
├── quickstart.md        # Phase 1 output (/sp.plan command)
├── contracts/           # Phase 1 output (/sp.plan command)
│   └── api-contracts.md # API endpoint specifications
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
frontend/
├── src/
│   ├── app/
│   │   ├── layout.tsx           # Root layout with providers
│   │   ├── page.tsx             # Landing/redirect page
│   │   ├── login/
│   │   │   └── page.tsx         # Login page
│   │   ├── signup/
│   │   │   └── page.tsx         # Signup page
│   │   └── dashboard/
│   │       ├── layout.tsx       # Authenticated layout
│   │       └── page.tsx         # Dashboard page
│   ├── components/
│   │   ├── ui/
│   │   │   ├── Button.tsx       # Base button component
│   │   │   ├── Input.tsx        # Base input component
│   │   │   └── Modal.tsx        # Base modal component
│   │   ├── layout/
│   │   │   ├── Header.tsx       # App header with logout
│   │   │   └── Layout.tsx       # Page layout wrapper
│   │   ├── auth/
│   │   │   ├── LoginForm.tsx    # Login form component
│   │   │   └── SignupForm.tsx   # Signup form component
│   │   └── tasks/
│   │       ├── TaskCard.tsx     # Individual task display
│   │       ├── TaskList.tsx     # Task list container
│   │       └── TaskForm.tsx     # Task create/edit form
│   ├── lib/
│   │   ├── api-client.ts        # Centralized API client
│   │   ├── auth.ts              # Better Auth configuration
│   │   └── types.ts             # TypeScript type definitions
│   └── middleware.ts            # Route protection middleware
├── public/
│   └── assets/                  # Static assets
├── .env.local                   # Environment variables
├── next.config.js               # Next.js configuration
├── tailwind.config.js           # Tailwind CSS configuration
├── tsconfig.json                # TypeScript configuration
└── package.json                 # Dependencies
```

**Structure Decision**: Web application structure (Option 2) selected. Frontend resides in dedicated /frontend directory with Next.js App Router conventions. Clear separation between pages (app/), reusable components (components/), and utilities (lib/). This structure supports the monorepo pattern while maintaining frontend isolation.

## Complexity Tracking

> No constitution violations detected. All requirements align with established principles.

---

## Phase 0: Research & Technology Decisions

### Research Areas

1. **Better Auth Integration with Next.js 16 App Router**
   - Decision: Use Better Auth with JWT strategy
   - Rationale: Better Auth provides built-in JWT support, httpOnly cookie management, and seamless Next.js integration
   - Alternatives considered: NextAuth.js (more complex setup), custom JWT implementation (reinventing the wheel)

2. **API Client Architecture**
   - Decision: Centralized axios-based client with interceptors
   - Rationale: Interceptors allow automatic JWT attachment and global error handling; axios provides better error handling than fetch
   - Alternatives considered: Native fetch with wrapper (less robust error handling), React Query (adds unnecessary complexity for this scope)

3. **State Management Strategy**
   - Decision: Local component state with React hooks
   - Rationale: Application scope is small; no complex state sharing needed; keeps architecture simple
   - Alternatives considered: Redux (overkill for this scope), Zustand (unnecessary dependency), Context API (not needed for isolated task operations)

4. **Form Handling Approach**
   - Decision: Controlled components with React state
   - Rationale: Simple forms with minimal validation; native approach sufficient
   - Alternatives considered: React Hook Form (adds dependency for minimal benefit), Formik (deprecated)

5. **Route Protection Strategy**
   - Decision: Next.js middleware for authentication checks
   - Rationale: Middleware runs before page render; prevents flash of unauthenticated content; centralized protection logic
   - Alternatives considered: Component-level checks (causes flash), HOC pattern (more boilerplate)

6. **Styling Approach**
   - Decision: Tailwind CSS utility classes
   - Rationale: Rapid development, consistent design system, minimal CSS bundle size
   - Alternatives considered: CSS Modules (more boilerplate), Styled Components (runtime overhead), plain CSS (harder to maintain)

7. **Error Boundary Strategy**
   - Decision: Global error boundary at root layout + local error states
   - Rationale: Catches unexpected errors while allowing granular error handling for API calls
   - Alternatives considered: Page-level only (misses component errors), component-level only (too granular)

8. **Loading State Pattern**
   - Decision: Local loading states with React Suspense for route transitions
   - Rationale: Immediate feedback for user actions; Suspense handles navigation loading automatically
   - Alternatives considered: Global loading state (causes unnecessary re-renders), no loading states (poor UX)

---

## Phase 1: Design & Contracts

### 1. Project Initialization Plan

**Step 1.1**: Initialize Next.js project in /frontend directory
- Create frontend directory at repository root
- Initialize Next.js 16+ with App Router using create-next-app
- Select TypeScript, Tailwind CSS, and App Router options
- Verify package.json includes Next.js 16+, React 19+, TypeScript 5+

**Step 1.2**: Configure TypeScript
- Ensure tsconfig.json uses strict mode
- Configure path aliases: @/components, @/lib, @/app
- Enable incremental compilation for faster builds
- Set target to ES2022 for modern browser support

**Step 1.3**: Configure Tailwind CSS
- Verify tailwind.config.js includes all source paths
- Configure custom color palette for consistent branding
- Add custom spacing and typography scales if needed
- Ensure dark mode support is disabled (not in scope)

**Step 1.4**: Install core dependencies
- Install Better Auth: `better-auth` package
- Install API client: `axios` for HTTP requests
- Install development dependencies: `@types/node`, `@types/react`
- Verify all dependencies are compatible with Next.js 16+

**Step 1.5**: Configure environment variables
- Create .env.local file with NEXT_PUBLIC_API_URL placeholder
- Add BETTER_AUTH_SECRET placeholder
- Document required environment variables in README
- Add .env.local to .gitignore

**Step 1.6**: Set up folder structure
- Create src/components/ui directory for base components
- Create src/components/layout directory for layout components
- Create src/components/auth directory for authentication components
- Create src/components/tasks directory for task components
- Create src/lib directory for utilities and API client
- Create src/app directory structure per routing requirements

---

### 2. Authentication Flow Plan

**Step 2.1**: Configure Better Auth
- Create src/lib/auth.ts configuration file
- Configure JWT strategy with httpOnly cookies
- Set token expiration to 7 days
- Configure callback URLs for login/signup success
- Define user session type with id and email fields

**Step 2.2**: Implement authentication API integration
- Add login method to API client: POST /api/auth/login
- Add signup method to API client: POST /api/auth/signup
- Add logout method to API client: POST /api/auth/logout
- Add session validation method: GET /api/auth/session
- Ensure all methods handle errors and return typed responses

**Step 2.3**: Create login page (src/app/login/page.tsx)
- Implement page component with LoginForm
- Handle unauthenticated-only access (redirect if already logged in)
- Include link to signup page
- Display page title "Login to Todo App"

**Step 2.4**: Create signup page (src/app/signup/page.tsx)
- Implement page component with SignupForm
- Handle unauthenticated-only access (redirect if already logged in)
- Include link to login page
- Display page title "Create Account"

**Step 2.5**: Implement LoginForm component
- Create controlled form with email and password inputs
- Add client-side validation (email format, password minimum length)
- Handle form submission with loading state
- Display error messages from API responses
- Redirect to /dashboard on success
- Include "Don't have an account? Sign up" link

**Step 2.6**: Implement SignupForm component
- Create controlled form with email and password inputs
- Add password confirmation field
- Add client-side validation (matching passwords, email format)
- Handle form submission with loading state
- Display error messages from API responses
- Redirect to /dashboard on success
- Include "Already have an account? Log in" link

**Step 2.7**: Implement logout functionality
- Add logout button to Header component
- Call logout API method on click
- Clear client-side session state
- Redirect to /login page after successful logout
- Handle logout errors gracefully

**Step 2.8**: Implement route protection middleware
- Create src/middleware.ts file
- Check for valid session on protected routes (/dashboard/*)
- Redirect to /login if session invalid
- Allow access to /login and /signup without authentication
- Redirect authenticated users away from /login and /signup to /dashboard

---

### 3. Layout & Navigation Plan

**Step 3.1**: Create root layout (src/app/layout.tsx)
- Define HTML structure with lang attribute
- Include metadata (title, description)
- Wrap children with Better Auth provider
- Apply global Tailwind CSS styles
- Set up font configuration (system fonts or custom)

**Step 3.2**: Create authenticated layout (src/app/dashboard/layout.tsx)
- Include Header component at top
- Wrap children in main content container
- Apply consistent padding and max-width constraints
- Ensure responsive behavior for mobile devices

**Step 3.3**: Create Header component (src/components/layout/Header.tsx)
- Display application name "Todo App" on left
- Display user email (from session) in center or right
- Include logout button on right
- Apply consistent styling with border-bottom
- Ensure responsive behavior (stack on mobile if needed)

**Step 3.4**: Create Layout component (src/components/layout/Layout.tsx)
- Accept children prop for page content
- Apply consistent padding and spacing
- Set max-width for content area (e.g., max-w-4xl)
- Center content horizontally
- Ensure responsive behavior

**Step 3.5**: Implement landing page redirect (src/app/page.tsx)
- Check authentication status
- Redirect authenticated users to /dashboard
- Redirect unauthenticated users to /login
- Show loading state during redirect

---

### 4. UI Component Implementation Plan

**Step 4.1**: Create Button component (src/components/ui/Button.tsx)
- Accept variant prop: primary, secondary, danger
- Accept size prop: small, medium, large
- Accept disabled and loading props
- Apply Tailwind classes for consistent styling
- Show loading spinner when loading prop is true
- Ensure proper TypeScript typing for all props
- Support onClick handler and children content

**Step 4.2**: Create Input component (src/components/ui/Input.tsx)
- Accept type prop: text, email, password
- Accept label, placeholder, and error props
- Display label above input field
- Display error message below input in red
- Apply consistent border and focus styles
- Ensure proper TypeScript typing
- Support value and onChange handlers

**Step 4.3**: Create Modal component (src/components/ui/Modal.tsx)
- Accept isOpen, onClose, title, and children props
- Render modal overlay with backdrop
- Center modal content on screen
- Include close button (X) in top-right corner
- Close modal when clicking backdrop
- Prevent body scroll when modal is open
- Apply consistent styling with shadow and rounded corners
- Ensure responsive behavior (full-screen on mobile)

**Step 4.4**: Verify component reusability
- Test Button with different variants and sizes
- Test Input with different types and error states
- Test Modal with different content types
- Ensure all components accept className prop for customization
- Document component props with TypeScript interfaces

---

### 5. Pages Implementation Plan

**Step 5.1**: Implement login page (already covered in Step 2.3)
- Verify page renders LoginForm correctly
- Verify redirect logic for authenticated users
- Verify link to signup page works

**Step 5.2**: Implement signup page (already covered in Step 2.4)
- Verify page renders SignupForm correctly
- Verify redirect logic for authenticated users
- Verify link to login page works

**Step 5.3**: Implement dashboard page (src/app/dashboard/page.tsx)
- Fetch tasks on page load using API client
- Display loading state while fetching
- Display TaskList component with fetched tasks
- Display empty state when no tasks exist
- Include "Add Task" button that opens TaskForm modal
- Handle task fetch errors with error message
- Implement task refetch after create/update/delete operations

**Step 5.4**: Implement task creation flow
- Add state for modal visibility in dashboard page
- Open TaskForm modal when "Add Task" button clicked
- Pass empty initial values to TaskForm
- Handle form submission: call create task API
- Close modal on successful creation
- Refetch tasks to show new task
- Display error message if creation fails

**Step 5.5**: Implement task editing flow
- Pass edit handler to TaskCard component
- Open TaskForm modal with task data when edit clicked
- Pass task data as initial values to TaskForm
- Handle form submission: call update task API
- Close modal on successful update
- Refetch tasks to show updated task
- Display error message if update fails

---

### 6. API Client Integration Plan

**Step 6.1**: Create centralized API client (src/lib/api-client.ts)
- Initialize axios instance with base URL from environment variable
- Configure default headers (Content-Type: application/json)
- Set timeout to 10 seconds
- Export configured axios instance

**Step 6.2**: Implement request interceptor
- Add interceptor to attach JWT token to all requests
- Retrieve token from Better Auth session
- Add token to Authorization header as "Bearer {token}"
- Allow requests to proceed if no token (for login/signup)

**Step 6.3**: Implement response interceptor
- Handle successful responses (return data directly)
- Handle 401 Unauthorized: clear session, redirect to /login
- Handle 403 Forbidden: show "Access denied" message
- Handle 500 Server Error: show "Server error, please try again"
- Handle network errors: show "Network error, check connection"
- Log errors to console for debugging

**Step 6.4**: Create task API methods
- getTasks(): GET /api/tasks - returns Task[]
- createTask(data): POST /api/tasks - returns Task
- updateTask(id, data): PUT /api/tasks/{id} - returns Task
- deleteTask(id): DELETE /api/tasks/{id} - returns void
- toggleTaskStatus(id): PATCH /api/tasks/{id}/toggle - returns Task

**Step 6.5**: Create TypeScript types (src/lib/types.ts)
- Define Task interface: id, title, description, completed, userId, createdAt, updatedAt
- Define TaskCreatePayload: title, description (optional)
- Define TaskUpdatePayload: title, description (optional), completed (optional)
- Define User interface: id, email
- Define APIError interface: message, statusCode

**Step 6.6**: Implement loading state management
- Use React useState for loading flags in components
- Set loading to true before API call
- Set loading to false after API call completes (success or error)
- Disable form submissions and buttons during loading
- Show loading spinner or skeleton UI during loading

**Step 6.7**: Implement error state management
- Use React useState for error messages in components
- Clear error state before new API call
- Set error state if API call fails
- Display error message to user in red text
- Provide retry mechanism where appropriate

---

### 7. State & Data Flow Plan

**Step 7.1**: Define local state usage guidelines
- Use useState for form inputs and validation errors
- Use useState for loading and error states
- Use useState for modal visibility
- Use useState for task list data
- Avoid prop drilling beyond 2 levels (use composition instead)

**Step 7.2**: Implement task fetching strategy
- Fetch tasks on dashboard page mount using useEffect
- Store tasks in local state (useState)
- Show loading state during initial fetch
- Show error state if fetch fails
- Provide manual refresh option if needed

**Step 7.3**: Define refetch rules after mutations
- After task creation: refetch task list
- After task update: refetch task list
- After task deletion: refetch task list
- After task status toggle: refetch task list
- Alternative: optimistic updates (update local state immediately, rollback on error)

**Step 7.4**: Implement empty state behavior
- Check if tasks array is empty after successful fetch
- Display friendly message: "No tasks yet. Create your first task!"
- Display large "Add Task" button as primary action
- Use icon or illustration to make empty state visually appealing

**Step 7.5**: Implement loading state behavior
- Show skeleton UI or spinner during initial task fetch
- Show inline spinner on buttons during form submission
- Disable interactive elements during loading
- Ensure loading states don't block entire UI unnecessarily

---

### 8. Task Component Implementation Plan

**Step 8.1**: Create TaskCard component (src/components/tasks/TaskCard.tsx)
- Accept task prop with Task type
- Accept onEdit, onDelete, onToggle callback props
- Display task title in bold
- Display task description below title (if present)
- Display status badge: "Completed" (green) or "Pending" (yellow)
- Include action buttons: Edit, Delete, Toggle Status
- Apply card styling with border, padding, and shadow
- Ensure responsive behavior

**Step 8.2**: Create TaskList component (src/components/tasks/TaskList.tsx)
- Accept tasks prop with Task[] type
- Accept onEdit, onDelete, onToggle callback props
- Map over tasks and render TaskCard for each
- Pass callbacks down to TaskCard components
- Apply grid or flex layout for task cards
- Ensure responsive behavior (single column on mobile)
- Handle empty tasks array (show empty state)

**Step 8.3**: Create TaskForm component (src/components/tasks/TaskForm.tsx)
- Accept initialValues prop (optional) for edit mode
- Accept onSubmit callback prop
- Accept onCancel callback prop
- Create controlled form with title and description inputs
- Add client-side validation (title required, max lengths)
- Display validation errors below inputs
- Include Submit and Cancel buttons
- Show loading state on submit button during API call
- Clear form after successful submission (create mode)
- Determine mode (create vs edit) based on initialValues presence

**Step 8.4**: Implement task deletion with confirmation
- Show confirmation modal when delete button clicked
- Modal message: "Are you sure you want to delete this task?"
- Include "Cancel" and "Delete" buttons in modal
- Call deleteTask API method on confirmation
- Show loading state during deletion
- Close modal and refetch tasks on success
- Display error message if deletion fails

**Step 8.5**: Implement task status toggle
- Call toggleTaskStatus API method when toggle button clicked
- Show loading state on button during API call
- Update task list on success (via refetch)
- Display error message if toggle fails
- Provide visual feedback (button disabled during loading)

---

### 9. UX & Quality Assurance Plan

**Step 9.1**: Implement loading indicators
- Add spinner component for general loading states
- Add skeleton UI for task list loading
- Add inline spinners for button loading states
- Ensure loading indicators are visually consistent
- Test loading states by simulating slow network

**Step 9.2**: Implement error messages
- Display error messages in red text below forms
- Display error messages in toast/alert for API failures
- Ensure error messages are user-friendly (no technical jargon)
- Provide actionable guidance in error messages
- Test error states by simulating API failures

**Step 9.3**: Implement empty task list UI
- Design friendly empty state with icon/illustration
- Include clear call-to-action: "Create your first task"
- Ensure empty state is visually centered and appealing
- Test empty state by starting with no tasks

**Step 9.4**: Perform accessibility checks
- Ensure all interactive elements are keyboard accessible
- Add proper ARIA labels to buttons and inputs
- Ensure sufficient color contrast (WCAG AA minimum)
- Test with screen reader (NVDA or VoiceOver)
- Add focus indicators to all interactive elements
- Ensure form inputs have associated labels

**Step 9.5**: Validate responsive behavior
- Test on mobile viewport (320px width minimum)
- Test on tablet viewport (768px width)
- Test on desktop viewport (1024px+ width)
- Ensure touch targets are at least 44x44px on mobile
- Ensure text is readable without zooming
- Test navigation and forms on mobile devices

**Step 9.6**: Perform cross-browser testing
- Test on Chrome (latest version)
- Test on Firefox (latest version)
- Test on Safari (latest version)
- Test on Edge (latest version)
- Verify consistent behavior across browsers
- Fix any browser-specific issues

---

### 10. Validation & Completion Criteria

**Feature Complete Criteria**:
- ✅ All pages render without errors (login, signup, dashboard)
- ✅ User can register a new account successfully
- ✅ User can login with valid credentials
- ✅ User can logout and session is terminated
- ✅ User can create a new task
- ✅ User can edit an existing task
- ✅ User can delete a task with confirmation
- ✅ User can toggle task status (complete/incomplete)
- ✅ All API calls include JWT authentication
- ✅ Unauthenticated users are redirected to login
- ✅ Authenticated users cannot access login/signup pages

**Constitution Compliance Criteria**:
- ✅ No manual coding performed (all generated by Claude Code)
- ✅ Frontend never directly accesses database
- ✅ All API calls go through centralized API client
- ✅ JWT tokens automatically attached to requests
- ✅ No direct fetch calls in UI components
- ✅ Code follows Spec-Kit folder conventions
- ✅ All changes derived from approved specifications

**Backend Integration Readiness Criteria**:
- ✅ API client configured with correct base URL
- ✅ All API endpoints match backend contract
- ✅ Request/response types match backend models
- ✅ JWT token format matches backend expectations
- ✅ Error handling covers all backend error codes
- ✅ CORS configuration documented for backend team

**Demo-Ready Criteria**:
- ✅ Application runs without console errors
- ✅ All user flows complete successfully
- ✅ UI is visually polished and professional
- ✅ Loading states provide clear feedback
- ✅ Error messages are user-friendly
- ✅ Empty states are handled gracefully
- ✅ Responsive design works on mobile and desktop
- ✅ Accessibility score meets 95% threshold
- ✅ Application can be demonstrated end-to-end in under 5 minutes

---

## Implementation Order

The implementation must follow this strict order to ensure dependencies are satisfied:

1. **Foundation** (Steps 1.1 - 1.6): Project initialization and configuration
2. **Authentication Setup** (Steps 2.1 - 2.2): Better Auth and API integration
3. **Base Components** (Steps 4.1 - 4.4): Button, Input, Modal
4. **Layouts** (Steps 3.1 - 3.5): Root layout, authenticated layout, Header
5. **Auth Pages** (Steps 2.3 - 2.6): Login and signup pages with forms
6. **Route Protection** (Step 2.8): Middleware for authentication checks
7. **API Client** (Steps 6.1 - 6.7): Centralized client with interceptors
8. **Task Components** (Steps 8.1 - 8.5): TaskCard, TaskList, TaskForm
9. **Dashboard** (Steps 5.3 - 5.5): Dashboard page with task management
10. **UX Polish** (Steps 9.1 - 9.6): Loading states, errors, accessibility
11. **Validation** (Step 10): Verify all completion criteria

---

## Risk Analysis

### Risk 1: Better Auth Configuration Complexity
- **Impact**: Medium - Could delay authentication implementation
- **Mitigation**: Follow official Better Auth documentation; use JWT strategy (simplest option)
- **Fallback**: Implement custom JWT handling if Better Auth proves incompatible

### Risk 2: JWT Token Management
- **Impact**: High - Security vulnerability if tokens exposed
- **Mitigation**: Use httpOnly cookies; never store tokens in localStorage; rely on Better Auth's built-in security
- **Fallback**: Consult security best practices documentation

### Risk 3: API Contract Mismatch
- **Impact**: High - Frontend won't work with backend
- **Mitigation**: Define clear API contracts in Phase 1; coordinate with backend team
- **Fallback**: Create mock API for frontend development

---

## Next Steps

After this plan is approved:
1. Run `/sp.tasks` to generate actionable task breakdown
2. Begin implementation following the order defined above
3. Create PHR for this planning session
4. Consider ADR for significant architectural decisions (API client strategy, state management approach)
